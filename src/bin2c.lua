local inputs = {}
local output
local name
local registercode
local onlyinput

local i = 1
while i <= select('#', ...) do
    local argv = select(i, ...)
    if onlyinput then
        inputs[#inputs + 1] = argv
    elseif argv == '-g' then
        registercode = true
    elseif argv == '-n' then
        i = i + 1
        name = select(i, ...)
    elseif argv == '-o' then
        i = i + 1
        output = select(i, ...)
    elseif argv == '--' then
        onlyinput = true
    else
        inputs[#inputs + 1] = {
            name = name,
            filename = argv
        }
    end
    i = i + 1
end

local function process_input(fout, name, input)
    local fh = assert(io.open(input, "rb"))
    local total = {}
    local len = 0
    local t = {}
    local col = 0
    local s = ""
    while true do
        local s = fh:read(1024)
        if not s then break end
        len = len + #s
        for i = 1, #s do local m = s:sub(i, i)
            if m:match "[\\\"\n\r\t]" then
                if     m == '\n' then t[#t+1] = '\\n'
                elseif m == '\r' then t[#t+1] = '\\r'
                elseif m == '\t' then t[#t+1] = '\\t'
                else                  t[#t+1] = '\\'..m
                end
                col = col + 2
            elseif m:match "%G" and m ~= ' ' then
                t[#t+1] = ("\\%03o"):format(string.byte(m))
                col = col + 4
            else
                t[#t+1] = m
                col = col + 1
            end
            if col >= 76 then
                total[#total+1] = '    "'..table.concat(t)..'"\n'
                t = {}
                col = 0
            end
        end
    end
    fh:close()

    total[#total+1] = '    "'..table.concat(t)..'"'

    io.write((([[
$(static)const char *$(name)_script = 
$(value);

$(static)size_t $(name)_script_len = $(len);

]]):gsub('%$%((%w+)%)', {
        name = name,
        value = table.concat(total),
        len = len,
        static = registercode and "static " or "",
    })))
end

local function escaped(filename)
    return filename:match '(%w+)%.lua':gsub("%I", "_")
end

io.output(output)
io.write [[
/*
** auto-generated by txt2c.lua
*/

]]

if registercode then
    io.write [[

#include <lua.h>
#include <lauxlib.h>
    ]]
else
    io.write [[

#include <stddef.h> /* for size_t */
    ]]
end


for k, v in ipairs(inputs) do
    process_input(io.output(), v.name or escaped(v.filename), v.filename)
end

io.write "/* end of scripts */\n\n"

if registercode then
    io.write "/* luaopen files */\n\n"
    for k, v in ipairs(inputs) do
        io.write ((([[
LUALIB_API int luaopen_$(name) (lua_State *L) {
    if (luaL_loadbuffer(L, $(name)_script,
            $(name)_script_len, $(filename)) != 0)
        return lua_error(L);
    lua_insert(L, 1);
    lua_call(L, lua_gettop(L) - 1, LUA_MULTRET);
    return lua_gettop(L);
}

]]):gsub('%$%((%w+)%)', {
        name = v.name or escaped(v.filename),
        filename = ("%q"):format("@"..v.filename),
    })))
    end
end

io.write [[
/* end of file */
]]
io.write():flush()
